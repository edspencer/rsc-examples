[[["errors/error-boundary",{"pageContent":"This example illustrates the use of an explicit error boundary in React Server Components to handle errors thrown by a server component. It highlights that the implementation is similar to client components, with the key distinction being that the error boundary itself is a server component. The example utilizes the `react-error-boundary` library to create the error boundary, although it notes that developers can also create their own custom error boundaries.\n\nThe provided code defines a `PageWithBoundary` component that includes an `ErrorBoundary` wrapping an `ErrorComponent`. When the `ErrorComponent` throws an error, the `ErrorBoundary` catches it and renders a fallback component, `ErrorFallback`, which displays an error message. This approach enhances user experience by providing a clear indication of an error, rather than showing a generic error or nothing at all.\n\nOverall, this example serves as a practical demonstration of error handling in React Server Components, emphasizing the importance of user-friendly error management.","metadata":{"sourceDocumentId":"errors/error-boundary"}}],["errors/error-tsx",{"pageContent":"This example demonstrates how to handle errors in React Server Components using the `error.tsx` convention. When a page throws an error, you can create an `error.tsx` file in the same or a parent directory to display a custom error message instead of the default error output. \n\nThe example includes a page component that intentionally throws an error within an `ErrorComponent`. Since the error is not caught within the component, the custom error message defined in `error.tsx` is rendered instead. The `error.tsx` file must be a client component because error handling occurs on the client side.\n\nThe provided code snippets illustrate the setup: the main page component includes an error-throwing component, while the `error.tsx` file defines a user-friendly error message. This approach enhances user experience by providing clearer feedback when errors occur, although it affects the entire app. The document also suggests that using explicit error boundaries can be a more refined way to manage errors, allowing other content on the page to remain visible.","metadata":{"sourceDocumentId":"errors/error-tsx"}}],["errors/no-handling",{"pageContent":"This example demonstrates the behavior of a React page when an error is thrown in a component without an error boundary to catch it. The `NoHandling` component includes an `ErrorComponent` that intentionally throws an error. When this occurs, the error propagates up to the nearest error boundary, which in this case is the root of the application. The output differs between development and production modes, affecting the overall user experience negatively. The example suggests improving error handling by implementing either an explicit error boundary or using a dedicated error handling component.","metadata":{"sourceDocumentId":"errors/no-handling"}}],["errors/reset",{"pageContent":"This example demonstrates how to implement error handling and retry functionality in React Server Components using an error boundary. The main component, `ResettablePage`, includes a child component, `ErrorComponent`, which randomly throws an error 50% of the time. When an error occurs, a fallback UI defined in `error.tsx` is displayed, featuring a \"Retry\" button that allows users to reset the page without refreshing the browser.\n\nThe `ErrorComponent` simulates a delay before potentially throwing an error, while the `ErrorMessage` component manages the retry logic. It uses the `useRouter` hook from Next.js to refresh the page when the \"Retry\" button is clicked. A spinner is shown during the reset process to enhance user experience.\n\nKey points include:\n- The `reset()` function provided by Next.js only resets the state of the error boundary, not the page itself.\n- The `router.refresh()` method is called to re-render the entire page, which is wrapped in a `startTransition` to prevent UI flickering.\n- The example emphasizes the importance of providing users with a way to recover from errors gracefully.\n\nFor more advanced error handling, the document suggests implementing retry functionality at the component level instead of the page level.","metadata":{"sourceDocumentId":"errors/reset"}}],["errors/reset-boundary",{"pageContent":"This example demonstrates how to handle errors in React Server Components using an `ErrorBoundary`. The main component, `ResettablePage`, includes a child component, `ErrorComponent`, which has a 50% chance of throwing an error. If an error occurs, the `ErrorBoundary` catches it and displays an `ErrorFallback` component, which includes a Reset button.\n\nThe `ErrorComponent` simulates a delay before potentially throwing an error, and if it succeeds, it renders a message. The `ErrorFallback` component provides a user-friendly way to retry loading the component by calling a `retry` function that refreshes the page using `router.refresh()`. This function is wrapped in a `startTransition` to prevent UI flickering during the refresh process.\n\nThe example emphasizes that while the `resetErrorBoundary` function resets the error state, it does not refresh the page; instead, `router.refresh()` is necessary for that. This approach allows users to recover from errors without needing to refresh the entire page, enhancing the user experience.","metadata":{"sourceDocumentId":"errors/reset-boundary"}}],["pages/fast/no-suspense",{"pageContent":"This example demonstrates the use of React Server Components without employing `<Suspense>` boundaries or a `loading.tsx` file. It illustrates a scenario where data is fetched from a simulated fast database, which returns results in approximately 20 milliseconds. The code defines an asynchronous function, `slowDataLoad`, that mimics a database call and resolves after a short delay. The main component, `Page`, awaits this data and renders it alongside a header and a note about the absence of `<Suspense>`. The key takeaway is that for quick data fetches, the lack of `<Suspense>` does not negatively impact performance, but developers should be cautious as slower fetches could lead to degraded user experience.","metadata":{"sourceDocumentId":"pages/fast/no-suspense"}}],["pages/slow/component-suspense",{"pageContent":"This example demonstrates the use of React Server Components with `<Suspense>` boundaries to optimize UI rendering. It showcases how to render static content immediately while handling asynchronous data fetching in a non-blocking manner. The main component, `Page`, includes a `DataComponent` that simulates a 3-second data fetch. By wrapping `DataComponent` in a `<Suspense>` boundary, the static content is rendered right away, and a loading placeholder is displayed until the data is ready. Once the data is fetched, it is streamed to the browser as part of the same HTTP request. This approach allows for efficient rendering and improved user experience by minimizing wait times for the user.","metadata":{"sourceDocumentId":"pages/slow/component-suspense"}}],["pages/slow/no-suspense",{"pageContent":"This example illustrates the impact of slow-loading data on the interactivity of an asynchronous React Server Component (RSC). It begins by defining a function, `slowDataLoad`, which simulates a database call that takes 2 seconds to resolve. The main `Page` component then awaits this data, causing the entire page to block until the data is fully loaded. As a result, users experience a delay of 2 seconds before any content is rendered, highlighting the downside of using async/await in this context.\n\nThe example emphasizes the importance of using Suspense boundaries for data that may take longer than 10 milliseconds to load. By doing so, developers can ensure that the UI remains responsive and displays content to users without unnecessary delays. The document suggests avoiding async/await in scenarios where data fetching could significantly hinder user experience, advocating for a more efficient approach to handle slow data loads.","metadata":{"sourceDocumentId":"pages/slow/no-suspense"}}],["pages/slow/page-suspense",{"pageContent":"This example demonstrates how to utilize the `loading.tsx` convention in Next.js to implement automatic full-page Suspense boundaries with React Server Components. It features a simulated database call through the `slowDataLoad()` function, which takes 2 seconds to return data. Without using Suspense, the page waits for the data to load before rendering any content.\n\nBy creating a `loading.tsx` file in the same directory as the `page.tsx`, Next.js automatically wraps the page component in a `<Suspense>` boundary, using the exported component from `loading.tsx` as a fallback. This allows a loading message to be displayed immediately while the data is being fetched, enhancing the user experience by showing a loading state for approximately 3 seconds before the actual content is rendered.\n\nThe example illustrates how the presence of `loading.tsx` effectively transforms the page's behavior, allowing for a smoother loading experience.","metadata":{"sourceDocumentId":"pages/slow/page-suspense"}}],["promises/rejected",{"pageContent":"This example demonstrates how to handle a rejected Promise in a React Server Component. The `getData` function simulates a data fetch that fails after a specified delay by returning a rejected Promise with an error message. The `RejectedPromisePage` component attempts to render a data table using this Promise, wrapped in a `Suspense` component that displays a loading message while waiting for the data.\n\nSince the Promise is rejected, the loading message remains indefinitely on the client side, and an error is logged on the server. The example highlights the importance of handling rejected Promises properly to improve user experience, suggesting the use of an ErrorBoundary for better error management.","metadata":{"sourceDocumentId":"promises/rejected"}}],["promises/rejected-handled",{"pageContent":"This example demonstrates how to handle rejected promises in React Server Components using an `ErrorBoundary`. The `getData` function simulates a data fetch that intentionally rejects a promise after a specified delay, which is crucial for testing error handling. The main component, `RejectedPromisePage`, utilizes the `ErrorBoundary` and `Suspense` components to manage the rendering of a table that relies on the promise. When the promise rejects, the `Suspense` fallback is replaced with an `ErrorFallback` component, providing a better user experience by avoiding a full-page error message. This approach highlights the importance of catching errors in asynchronous operations within React applications.","metadata":{"sourceDocumentId":"promises/rejected-handled"}}],["promises/rendering-components",{"pageContent":"This example demonstrates how to utilize React Server Components (RSC) in conjunction with Promises to stream a fully-rendered React component from the server to the client. The main focus is on rendering a component that may take a significant amount of time to generate, allowing for a smoother user experience.\n\nThe code snippet includes a `SuspensePage` component that renders a message on the server and then uses a `Suspense` boundary to display a server-rendered component that takes 2 seconds to generate. This is achieved through the `renderHeavyComponent` function, which returns a Promise that resolves to a `ServerChildComponent` containing some data.\n\nThe `ClientPortal` component is a client-side component that accepts a Promise and uses the `use` hook to resolve it, rendering the resulting ReactNode. While this pattern may not be optimal for simple cases, it effectively illustrates the potential of using Promises with RSC for dynamically generating and delivering React content asynchronously after the initial UI has rendered. \n\nOverall, this example serves as a practical demonstration of how to leverage RSC and Promises for improved rendering strategies in React applications.","metadata":{"sourceDocumentId":"promises/rendering-components"}}],["promises/resolved",{"pageContent":"This example demonstrates how to use React Server Components to stream data from the server to the client using Promises. The main feature is the ability to initiate a data request on the server, which returns a Promise that can be sent to the client. The client can then wait for this Promise to resolve without blocking the rendering of the rest of the UI.\n\nThe example consists of a simple page that includes a server component rendering static content and a data table. The `<Table>` component receives a `dataPromise` prop, which is a Promise that resolves to an array of objects after a simulated delay of 1000 milliseconds. \n\nThe `getData` function simulates fetching data from a fake database, returning a Promise that resolves with an array of user objects after the specified delay. The `<Table>` component, marked as a client component, uses the `use` hook to wait for the `dataPromise` to resolve before rendering the table with the fetched data.\n\nOverall, this example illustrates the seamless integration of server and client components in React, allowing for efficient data fetching and rendering.","metadata":{"sourceDocumentId":"promises/resolved"}}],["promises/various-datatypes",{"pageContent":"This example demonstrates how to stream various types of data to the client using React Server Components and Promises. It showcases the ability to handle different data types, including strings, integers, floats, plain JSON objects, arrays, and rendered React components. \n\nThe core of the example is the `getData` function, which simulates fetching data with specified delays. A custom component, `<SuspenseWrapper>`, is used to wrap the `<ClientPromise>` component within a `<Suspense>` boundary, allowing for the streaming of data as it resolves. The `ClientPromise` component is responsible for rendering the resolved data, displaying it differently based on its type.\n\nAdditionally, the example includes a demonstration of returning a rendered React component from a Promise, highlighting the capability of React Server Components to return complex client-side components. The `<ClientPortal>` component is used to illustrate this feature, although it is noted that the `<Suspense>` boundary alone can suffice in many cases.\n\nOverall, this example serves as a practical guide for implementing data streaming in React applications using Server Components and Promises, with a focus on maintaining clean and reusable code through the use of custom components.","metadata":{"sourceDocumentId":"promises/various-datatypes"}}],["server-actions/form-status",{"pageContent":"This example demonstrates how to use React Server Components with a focus on providing user feedback during form submissions. It highlights the use of the `useFormStatus` hook to display a loading spinner while waiting for a server response, simulating a slow server with a 3-second delay. \n\nThe code snippet showcases a `SlowForm` component that utilizes `useFormState` to manage form submission state and display messages based on the submission status. A separate `SubmitButton` component is created to handle the loading state, as `useFormStatus` cannot be used in the same component as the form. This separation allows for reusability of the button across different forms.\n\nAdditionally, the example emphasizes the importance of implementing authentication for server actions in real-world applications, as these endpoints require careful consideration regarding security. \n\nOverall, this example serves as a practical guide for implementing user feedback in forms using React Server Components and managing form states effectively.","metadata":{"sourceDocumentId":"server-actions/form-status"}}],["server-actions/form-zod-validation",{"pageContent":"This example demonstrates how to use React Server Components with Next.js to validate form data using the Zod library. It focuses on creating a form that collects device information and validates the input on the server side before submission. \n\nThe example includes a Zod schema that defines the structure and validation rules for the form fields, such as device name, type, and hostname. The server action processes the form data, validates it against the schema, and either creates a device or returns validation error messages if the input is invalid.\n\nThe form component is designed to display validation errors for each field, providing user feedback directly in the UI. It also includes helper functions to manage error states and display success messages upon successful device creation.\n\nAdditionally, the example emphasizes the importance of implementing authentication for server actions in real-world applications, as these endpoints are not automatically secured.\n\nOverall, this example serves as a practical guide for integrating form validation in React Server Components using Next.js and Zod.","metadata":{"sourceDocumentId":"server-actions/form-zod-validation"}}],["server-actions/simple-form",{"pageContent":"This example demonstrates how to create a simple form in React using Server Actions with Next.js. It utilizes the `useFormState` hook to manage form submissions directly to the server. The form allows users to input a device name, and upon submission, it triggers a server action defined in a separate file.\n\nThe `AddDeviceForm` component includes a text input for the device name and a submit button. It displays success or error messages based on the submission outcome. The server action, `createDeviceAction`, processes the form data, simulating a device creation with a random ID and performing basic validation to ensure the name is provided.\n\nThe example emphasizes the need to mark the form component as a client component with `'use client'` and the server action with `'use server'`. It also highlights the importance of considering authentication for server actions in real applications.\n\nFinally, the form is rendered within a page component, allowing for standard form behavior, including keyboard submission. The document notes the distinction between `useFormState` and `useActionState`, indicating that the choice depends on the React version being used.\n\nThis example serves as a practical guide for implementing server-side form handling in React applications using Next.js.","metadata":{"sourceDocumentId":"server-actions/simple-form"}}],["static-pages/server-client",{"pageContent":"This example demonstrates how to effectively combine server and client components using React Server Components (RSC) with Next.js. It features a server-rendered page that includes a child component, `<MicrophoneList />`, which is designated as a client component due to its need to interact with browser-specific APIs, such as accessing the microphone.\n\nThe main page component, defined in `page.tsx`, renders a header and a paragraph indicating that it is server-rendered, followed by the `<MicrophoneList />` component. \n\nThe `<MicrophoneList />` component, located in `microphonelist.tsx`, utilizes the `'use client'` directive to indicate that it should run in the browser. It employs the `useEffect` hook to asynchronously fetch a list of available microphones using a utility function, `getMicrophones`, and stores this data in the component's state. The component then displays the list of microphones, demonstrating its capability to access the mediaDevices API.\n\nThis example highlights the seamless integration of server-rendered content with client-side interactivity, showcasing how to manage components that require different execution contexts within a Next.js application.","metadata":{"sourceDocumentId":"static-pages/server-client"}}],["static-pages/server-only",{"pageContent":"This example demonstrates how to utilize React Server Components (RSC) in a Next.js application, focusing on rendering the entire UI on the server when interactivity is not required. It explains that components without the `'use client'` directive are server components by default. \n\nThe example includes a `layout.tsx` file that defines a synchronous server component for the root layout, which wraps the children components in an HTML structure. The `page.tsx` file is an asynchronous function that loads product data using an `await` statement, allowing for data fetching before rendering. It displays a store title, product name, and description, along with a sub-component called `MyComponent`.\n\nThe `loadProductData` function simulates fetching data from a database or API with a delay, returning a product object containing a name, price, and description. The `MyComponent` is a simple server-rendered component that outputs a paragraph.\n\nOverall, the example illustrates how to structure a Next.js application using server components to optimize rendering without client-side interactivity.","metadata":{"sourceDocumentId":"static-pages/server-only"}}]],{"0":"errors/error-boundary","1":"errors/error-tsx","2":"errors/no-handling","3":"errors/reset","4":"errors/reset-boundary","5":"pages/fast/no-suspense","6":"pages/slow/component-suspense","7":"pages/slow/no-suspense","8":"pages/slow/page-suspense","9":"promises/rejected","10":"promises/rejected-handled","11":"promises/rendering-components","12":"promises/resolved","13":"promises/various-datatypes","14":"server-actions/form-status","15":"server-actions/form-zod-validation","16":"server-actions/simple-form","17":"static-pages/server-client","18":"static-pages/server-only"}]